import{_ as s,c as a,o as e,a4 as i}from"./chunks/framework.ClEHkwpW.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/nodejs/npm.md","filePath":"frontend/nodejs/npm.md"}'),n={name:"frontend/nodejs/npm.md"},p=i(`<h2 id="npm-run-xxx-运行流程" tabindex="-1">npm run xxx 运行流程 <a class="header-anchor" href="#npm-run-xxx-运行流程" aria-label="Permalink to &quot;npm run xxx 运行流程&quot;">​</a></h2><ol><li>在理解<code>npm run XXX</code>之前，我们需要知道<code>npm install</code>时会做的一步操作，npm 读到该配置后，就将执行脚本软链接到<code>./node_modules/.bin</code>目录下， 而<code>npm run xxx</code>还会自动把<code>node_modules/.bin</code>加入<code>$PATH</code>环境变量中，可以直接作为命令运行依赖程序和开发依赖程序，不用全局安装。 执行结束后，再将<code>$PATH</code>变量恢复原样</li><li>会去<code>package.json</code>的<code>script</code>对象中查找到<code>XXX</code>，例如在<code>umi</code>的项目中执行<code>npm run start</code>就会去执行<code>start</code>对应的umi脚本<code>&quot;start&quot;:&quot;umi dev&quot;</code>。 而直接执行<code>umi dev</code>这条命令的话系统会报错，因为<code>umi</code>不是全局指令。</li><li>在执行脚本的时候，系统会默认访问<code>./node_modules/.bin/</code>目录中创建好<code>umi的</code>几个可执行文件，执行<code>umi dev</code>的命令就相当于执行了<code>./node_modules/.bin/umi dev</code></li></ol><h2 id="npm-link" tabindex="-1">npm link <a class="header-anchor" href="#npm-link" aria-label="Permalink to &quot;npm link&quot;">​</a></h2><p>如何高效率在本地调试以验证包的可用性呢？</p><p>一个“笨”方法是，手动复制粘贴组件并打包产出到业务项目的<code>node_modules</code>中进行验证，但是这种做法既不安全也会使得项目混乱， 变得难以维护，同时过于依赖手工执行，这种操作非常原始。</p><p>使用<code>npm link</code>。它本质就是软链接，可以将模块链接到对应的业务项目中运行，主要做了两件事：</p><ol><li>为目标 npm 模块（npm-package-1）创建软链接，将其链接到全局 node 模块安装路径 <code>/usr/local/lib/node_modules/</code>中；</li><li>为目标 npm 模块（npm-package-1）的可执行 bin 文件创建软链接，将其链接到全局 node 命令安装路径<code>/usr/local/bin/</code>中。</li></ol><p>我们来看一个具体场景，假设你正在开发项目 project 1，其中有个包 package 1，对应 npm 模块包名称是 npm-package-1， 我们在 package 1 项目中加入了新功能 feature A，现在要验证在 project 1 项目中能否正常使用 package 1 的 feature A，你应该怎么做？</p><ol><li>我们先在 package 1 目录中，执行<code>npm link</code>，这样 npm link 通过链接目录和可执行文件，实现npm包命令的全局可执行。</li><li>然后在 project 1 中创建链接，执行<code>npm link npm-package-1</code>命令时，它就会去<code>/usr/local/lib/node_modules/</code>这个路径下寻找是否有这个包，如果有就建立软链接。</li></ol><p>这样一来，我们就可以在 project 1 的 node_module 中会看到链接过来的模块包 npm-package-1，此时的 npm-package-1 就带有最新开发的 feature A， 这样一来就可以在 project 1 中正常开发调试 npm-package-1。当然别忘了，调试结束后可以执行<em><strong>npm unlink</strong></em>以取消关联。</p><h2 id="npx" tabindex="-1">npx <a class="header-anchor" href="#npx" aria-label="Permalink to &quot;npx&quot;">​</a></h2><h3 id="调用项目安装的模块" tabindex="-1">调用项目安装的模块 <a class="header-anchor" href="#调用项目安装的模块" aria-label="Permalink to &quot;调用项目安装的模块&quot;">​</a></h3><p>npx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了测试工具 typescript</p><p>一般来说调用 <code>tsc</code>，只能在项目脚本和package.json 的scripts字段里面， 如果想在命令行下调用，必须像下面这样</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 项目的根目录下执行</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node-modules/.bin/tsc</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --version</span></span></code></pre></div><p>npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tsc</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --version</span></span></code></pre></div><h3 id="避免全局安装模块" tabindex="-1">避免全局安装模块 <a class="header-anchor" href="#避免全局安装模块" aria-label="Permalink to &quot;避免全局安装模块&quot;">​</a></h3><p>除了调用项目内部模块，npx还能避免全局安装的模块。比如，<code>create-react-app</code> 这个模块是全局安装，npx可以运行它，而且不进行全局安装</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> create-react-app</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> react-demo</span></span></code></pre></div><p>上面代码运行时，npx将 <code>create-react-app</code> 下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载 <code>create-react-app</code></p><p>下载全局模块时，npx允许指定版本</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> uglify-js@3.1.0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main.js</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./dist/main.js</span></span></code></pre></div><p>上面代码指定使用 3.1.0 版本的uglify-js压缩脚本</p><p>注意，只要npx后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装 <code>http-server</code> 模块，下面的命令会自动下载该模块，在当前目录启动一个Web服务</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> http-server</span></span></code></pre></div><h3 id="执行-github-源码" tabindex="-1">执行 GitHub 源码 <a class="header-anchor" href="#执行-github-源码" aria-label="Permalink to &quot;执行 GitHub 源码&quot;">​</a></h3><p>npx 还可以执行GitHub上面的模块源码。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 执行 Gist 代码</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 执行仓库代码</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> github:piuccio/cowsay</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hello</span></span></code></pre></div><h2 id="corepack" tabindex="-1">Corepack <a class="header-anchor" href="#corepack" aria-label="Permalink to &quot;Corepack&quot;">​</a></h2><p><code>Corepack</code>是一个实验性工具，在 <code>Node.js v16.13</code> 版本中引入，它可以指定项目使用的包管理器以及版本, 简单来说，<code>Corepack</code> 会成为 Node.js 官方的内置 CLI，用来管理包管理工具（npm、yarn、pnpm、cnpm），用户无需手动安装，即<strong>包管理器的管理器</strong></p><p>主要作用：</p><ul><li>不再需要专门全局安装 yarn pnpm 等工具</li><li>可以强制团队项目中使用他特定的包管理器版本，而无需他们在每次需要进行更新时手动同步它，如果不符合配置将在控制台进行错误提示</li></ul><p>在项目 package.json 文件中新增属性 <code>&quot;packageManager&quot;</code>，代表当前项目只允许使用yarn 包管理器并指定1.22.15版本</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;packageManager&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;yarn@1.22.15&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>激活corepack</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">corepack</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> enable/disable</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">corepack</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> prepare</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pnpm@latest</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --activate</span></span></code></pre></div>`,37),t=[p];function l(o,c,d,h,r,k){return e(),a("div",null,t)}const m=s(n,[["render",l]]);export{u as __pageData,m as default};
