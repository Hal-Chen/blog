import{_ as s,c as a,o as n,a4 as i}from"./chunks/framework.ClEHkwpW.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/bom/Server_Sent_Events.md","filePath":"frontend/bom/Server_Sent_Events.md"}'),e={name:"frontend/bom/Server_Sent_Events.md"},p=i(`<h2 id="sse-的本质" tabindex="-1">SSE 的本质 <a class="header-anchor" href="#sse-的本质" aria-label="Permalink to &quot;SSE 的本质&quot;">​</a></h2><p>严格地说，HTTP 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息（streaming）。</p><p>也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流， 视频播放就是这样的例子。本质上，这种通信就是以流信息的方式，完成一次用时很长的下载。</p><p>SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 HTTP 协议，目前除了 IE/Edge，其他浏览器都支持。</p><h2 id="sse-的特点" tabindex="-1">SSE 的特点 <a class="header-anchor" href="#sse-的特点" aria-label="Permalink to &quot;SSE 的特点&quot;">​</a></h2><p>SSE 与 WebSocket 作用相似，都是建立浏览器与服务器之间的通信渠道，然后服务器向浏览器推送信息。</p><p>总体来说，WebSocket 更强大和灵活。因为它是全双工通道，可以双向通信；SSE 是单向通道， 只能服务器向浏览器发送，因为流信息本质上就是下载。如果浏览器向服务器发送信息， 就变成了另一次 HTTP 请求。</p><ul><li>SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议</li><li>SSE 属于轻量级，使用简单；WebSocket 协议相对复杂。</li><li>SSE 默认支持断线重连，WebSocket 需要自己实现</li><li>SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据</li><li>SSE 支持自定义发送的消息类型</li></ul><h2 id="客户端-api" tabindex="-1">客户端 API <a class="header-anchor" href="#客户端-api" aria-label="Permalink to &quot;客户端 API&quot;">​</a></h2><p>SSE 的客户端 API 部署在EventSource对象上。使用 SSE 时，浏览器首先生成一个EventSource实例，向服务器发起连接。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EventSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url);</span></span></code></pre></div><p>上面的url可以与当前网址同域，也可以跨域。跨域时，可以指定第二个参数，打开withCredentials属性，表示是否一起发送 Cookie。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EventSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url, { withCredentials: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div><p>EventSource实例的readyState属性，表明连接的当前状态。该属性只读，可以取以下值</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>0：相当于常量EventSource.CONNECTING，表示连接还未建立，或者断线正在重连。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1：相当于常量EventSource.OPEN，表示连接已经建立，可以接受数据。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>2：相当于常量EventSource.CLOSED，表示连接已断，且不会重连</span></span></code></pre></div><p>连接一旦建立，就会触发open事件，可以在onopen属性定义回调函数</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onopen</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;open&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>客户端收到服务器发来的数据，就会触发message事件，可以在onmessage属性的回调函数</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event.data;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // handle message</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event.data;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // handle message</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>如果发生通信错误（比如连接中断），就会触发error事件，可以在onerror属性定义回调函数</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onerror</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // handle error event</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;error&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // handle error event</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>close方法用于关闭 SSE 连接</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h2 id="服务器实现" tabindex="-1">服务器实现 <a class="header-anchor" href="#服务器实现" aria-label="Permalink to &quot;服务器实现&quot;">​</a></h2><p>服务器向浏览器发送的 SSE 数据，必须是 UTF-8 编码的文本，具有如下的 HTTP 头信息</p><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> text/event-stream</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Cache-Control</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> no-cache</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Connection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> keep-alive</span></span></code></pre></div><p>每一次发送的信息，由若干个message组成，每个message之间用\\n\\n分隔。每个message内部由若干行组成，每一行都是如下格式</p><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]: value\\n</span></span></code></pre></div><p>上面的field可以取四个值</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>data</span></span>
<span class="line"><span>event</span></span>
<span class="line"><span>id</span></span>
<span class="line"><span>retry</span></span></code></pre></div><p>此外，还可以有冒号开头的行，表示注释。通常，服务器每隔一段时间就会向浏览器发送一个注释，保持连接不中断</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>: This is a comment</span></span></code></pre></div><p>下面是一个例子。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>: this is a test stream\\n\\n</span></span>
<span class="line"><span></span></span>
<span class="line"><span>data: some text\\n\\n</span></span>
<span class="line"><span>data: another message\\n</span></span>
<span class="line"><span>data: with two lines \\n\\n</span></span></code></pre></div><p><strong>data 字段</strong></p><p>数据内容用data字段表示,如果数据很长，可以分成多行，最后一行用\\n\\n结尾，前面行都用\\n结尾</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>data: begin message\\n</span></span>
<span class="line"><span></span></span>
<span class="line"><span>data: continue message\\n\\n</span></span></code></pre></div><p><strong>id 字段</strong></p><p>数据标识符用id字段表示，相当于每一条数据的编号。 浏览器用lastEventId属性读取这个值。一旦连接断线，浏览器会发送一个 HTTP 头， 里面包含一个特殊的Last-Event-ID头信息，将这个值发送回来，用来帮助服务器端重建连接。 因此，这个头信息可以被视为一种同步机制</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>id: msg1\\n</span></span>
<span class="line"><span></span></span>
<span class="line"><span>data: message\\n\\n</span></span></code></pre></div><p><strong>event 字段</strong></p><p>event字段表示自定义的事件类型，默认是message事件。浏览器可以用addEventListener()监听该事件</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>event: userconnect</span></span>
<span class="line"><span>data: {&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:33:48&quot;}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>event: usermessage</span></span>
<span class="line"><span>data: {&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:34:11&quot;, &quot;text&quot;: &quot;Hi everyone.&quot;}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>event: userdisconnect</span></span>
<span class="line"><span>data: {&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:34:23&quot;}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>event: usermessage</span></span>
<span class="line"><span>data: {&quot;username&quot;: &quot;sean&quot;, &quot;time&quot;: &quot;02:34:36&quot;, &quot;text&quot;: &quot;Bye, bobby.&quot;}</span></span></code></pre></div><p><strong>retry 字段</strong></p><p>服务器可以用retry字段，指定浏览器重新发起连接的时间间隔</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>retry: 10000\\n</span></span></code></pre></div><p>两种情况会导致浏览器重新发起连接：一种是时间间隔到期，二是由于网络错误等原因，导致连接出错</p><h2 id="node-服务器实例" tabindex="-1">Node 服务器实例 <a class="header-anchor" href="#node-服务器实例" aria-label="Permalink to &quot;Node 服务器实例&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let http = require(&quot;http&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>http.createServer(function (req, res) {</span></span>
<span class="line"><span>  const fileName = &quot;.&quot; + req.url;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  if (fileName === &quot;./stream&quot;) {</span></span>
<span class="line"><span>    res.writeHead(200, {</span></span>
<span class="line"><span>      &quot;Content-Type&quot;:&quot;text/event-stream&quot;,</span></span>
<span class="line"><span>      &quot;Cache-Control&quot;:&quot;no-cache&quot;,</span></span>
<span class="line"><span>      &quot;Connection&quot;:&quot;keep-alive&quot;,</span></span>
<span class="line"><span>      &quot;Access-Control-Allow-Origin&quot;: &#39;*&#39;,</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>    res.write(&quot;retry: 10000\\n&quot;);</span></span>
<span class="line"><span>    res.write(&quot;event: connecttime\\n&quot;);</span></span>
<span class="line"><span>    res.write(&quot;data: &quot; + (new Date()) + &quot;\\n\\n&quot;);</span></span>
<span class="line"><span>    res.write(&quot;data: &quot; + (new Date()) + &quot;\\n\\n&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    interval = setInterval(function () {</span></span>
<span class="line"><span>      res.write(&quot;data: &quot; + (new Date()) + &quot;\\n\\n&quot;);</span></span>
<span class="line"><span>    }, 1000);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    req.connection.addListener(&quot;close&quot;, function () {</span></span>
<span class="line"><span>      clearInterval(interval);</span></span>
<span class="line"><span>    }, false);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}).listen(8844, &quot;127.0.0.1&quot;);</span></span></code></pre></div>`,49),t=[p];function l(h,k,o,r,c,d){return n(),a("div",null,t)}const u=s(e,[["render",l]]);export{g as __pageData,u as default};
