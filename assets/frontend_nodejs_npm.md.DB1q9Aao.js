import{_ as e,c as s,o as a,a4 as n}from"./chunks/framework.ClEHkwpW.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/nodejs/npm.md","filePath":"frontend/nodejs/npm.md"}'),i={name:"frontend/nodejs/npm.md"},p=n(`<h2 id="npm-run-xxx-运行流程" tabindex="-1">npm run xxx 运行流程 <a class="header-anchor" href="#npm-run-xxx-运行流程" aria-label="Permalink to &quot;npm run xxx 运行流程&quot;">​</a></h2><ol><li>在理解<code>npm run XXX</code>之前，我们需要知道<code>npm install</code>时会做的一步操作，npm 读到该配置后，就将执行脚本软链接到<code>./node_modules/.bin</code>目录下， 而<code>npm run xxx</code>还会自动把<code>node_modules/.bin</code>加入<code>$PATH</code>环境变量中，可以直接作为命令运行依赖程序和开发依赖程序，不用全局安装。 执行结束后，再将<code>$PATH</code>变量恢复原样</li><li>会去<code>package.json</code>的<code>script</code>对象中查找到<code>XXX</code>，例如在<code>umi</code>的项目中执行<code>npm run start</code>就会去执行<code>start</code>对应的umi脚本<code>&quot;start&quot;:&quot;umi dev&quot;</code>。 而直接执行<code>umi dev</code>这条命令的话系统会报错，因为<code>umi</code>不是全局指令。</li><li>在执行脚本的时候，系统会默认访问<code>./node_modules/.bin/</code>目录中创建好<code>umi的</code>几个可执行文件，执行<code>umi dev</code>的命令就相当于执行了<code>./node_modules/.bin/umi dev</code></li></ol><h2 id="npm-link" tabindex="-1">npm link <a class="header-anchor" href="#npm-link" aria-label="Permalink to &quot;npm link&quot;">​</a></h2><p>如何高效率在本地调试以验证包的可用性呢？</p><p>一个“笨”方法是，手动复制粘贴组件并打包产出到业务项目的<code>node_modules</code>中进行验证，但是这种做法既不安全也会使得项目混乱， 变得难以维护，同时过于依赖手工执行，这种操作非常原始。</p><p>使用<code>npm link</code>。它本质就是软链接，可以将模块链接到对应的业务项目中运行，主要做了两件事：</p><ol><li>为目标 npm 模块（npm-package-1）创建软链接，将其链接到全局 node 模块安装路径 <code>/usr/local/lib/node_modules/</code>中；</li><li>为目标 npm 模块（npm-package-1）的可执行 bin 文件创建软链接，将其链接到全局 node 命令安装路径<code>/usr/local/bin/</code>中。</li></ol><p>我们来看一个具体场景，假设你正在开发项目 project 1，其中有个包 package 1，对应 npm 模块包名称是 npm-package-1， 我们在 package 1 项目中加入了新功能 feature A，现在要验证在 project 1 项目中能否正常使用 package 1 的 feature A，你应该怎么做？</p><ol><li>我们先在 package 1 目录中，执行<code>npm link</code>，这样 npm link 通过链接目录和可执行文件，实现npm包命令的全局可执行。</li><li>然后在 project 1 中创建链接，执行<code>npm link npm-package-1</code>命令时，它就会去<code>/usr/local/lib/node_modules/</code>这个路径下寻找是否有这个包，如果有就建立软链接。</li></ol><p>这样一来，我们就可以在 project 1 的 node_module 中会看到链接过来的模块包 npm-package-1，此时的 npm-package-1 就带有最新开发的 feature A， 这样一来就可以在 project 1 中正常开发调试 npm-package-1。当然别忘了，调试结束后可以执行<em><strong>npm unlink</strong></em>以取消关联。</p><h2 id="npx的作用" tabindex="-1">npx的作用 <a class="header-anchor" href="#npx的作用" aria-label="Permalink to &quot;npx的作用&quot;">​</a></h2><p>npx 执行「npm execute」npm包的二进制文件， npx由<em><strong>npm v5.2</strong></em>版本引入，解决了npm的一些使用快速开发、调试，以及项目内使用全局模块的痛点。 在传统npm模式下，如果我们需要使用代码检测工具ESLint，就要先通过npm install安装：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> eslint</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --save-dev</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./node_modules/.bin/eslint</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --init</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./node_modules/.bin/eslint</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> yourfile.js</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 而使用npx就简单多了，你只需要下面2个操作步骤：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> eslint</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --init</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> eslint</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> yourfile.js</span></span></code></pre></div><p>为什么 npx 操作起来如此便捷呢？</p><p>这是因为它可以直接执行<code>node_modules/.bin</code>文件夹下的文件。在运行命令时，<code>npx</code>可以自动去<code>node_modules/.bin</code>路径和环境变量<code>$PATH</code>里面检查命令是否存在， 而不需要再在<code>package.json</code>中定义相关的 <code>script</code>。</p><p>npx 另一个更实用的好处是：npx 执行模块时会优先安装依赖，但是在安装执行后便删除此依赖，这就避免了全局安装模块带来的问题。 运行如下命令后，<code>npx</code>会将<code>create-react-app</code>下载到一个临时目录，使用以后再删除：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> create-react-app</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cra-project</span></span></code></pre></div><h2 id="corepack" tabindex="-1">Corepack <a class="header-anchor" href="#corepack" aria-label="Permalink to &quot;Corepack&quot;">​</a></h2><p><code>Corepack</code>是一个实验性工具，在 <code>Node.js v16.13</code> 版本中引入，它可以指定项目使用的包管理器以及版本, 简单来说，<code>Corepack</code> 会成为 Node.js 官方的内置 CLI，用来管理包管理工具（npm、yarn、pnpm、cnpm），用户无需手动安装，即<strong>包管理器的管理器</strong></p><p>主要作用：</p><ul><li>不再需要专门全局安装 yarn pnpm 等工具</li><li>可以强制团队项目中使用他特定的包管理器版本，而无需他们在每次需要进行更新时手动同步它，如果不符合配置将在控制台进行错误提示</li></ul><p>在项目 package.json 文件中新增属性 <code>&quot;packageManager&quot;</code>，代表当前项目只允许使用yarn 包管理器并指定1.22.15版本</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;packageManager&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;yarn@1.22.15&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>激活corepack</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">corepack</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> enable/disable</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">corepack</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> prepare</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pnpm@latest</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --activate</span></span></code></pre></div>`,25),o=[p];function l(t,d,c,h,k,r){return a(),s("div",null,o)}const g=e(i,[["render",l]]);export{u as __pageData,g as default};
